// var path = require('path')
var fs = require('fs')

var pad = function(integer, digits) {
    var number, length;
    number = integer.toString()
    length = number.length;
    for(var i = 0; i < (digits - length); i++) {
        number = "0" + number;
    }
    
    return number;
}

var srtTimeToSeconds = function(srtTime) {
    var index, seconds;
    if(typeof srtTime === "number") {
        return srtTime;
    }
    seconds = 0;
    srtTime = srtTime.split(":");
    for(var i = 0; i < srtTime.length; i++) {
        index = srtTime.length - i - 1;
        seconds += parseFloat(srtTime[index].replace(",", ".")) * Math.pow(60, i);
    }
    
    return seconds;
}

var secondsToSrtTime = function(seconds) {
    var hours, minutes, seconds, millis;
    if(typeof seconds === "string" && ~seconds.indexOf(":")) {
        return seconds;
    }
    hours = Math.floor(seconds / 3600);
    seconds = seconds % 3600;
    minutes = Math.floor(seconds / 60);
    seconds = seconds % 60;
    millis = seconds - Math.floor(seconds);
    seconds -= millis;
    millis = millis.toFixed(3) * 1000;
    
    return pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "," + pad(millis, 3)
}

var Subtitle = function(subtitleBlock) {
    var splitTime, startTime, endTime, text;
    subtitleBlock = subtitleBlock.split("\n");
    if(subtitleBlock.length < 3) {
        throw Error("Invalid subtitle block: Not enough lines");
    } else {
        // Line 0 is the index, which we ignore
        // Line 1 is "startTime --> endTime"
        splitTime = subtitleBlock[1].split(" --> ");
        if(splitTime.length != 2) {
            throw Error("Invalid subtitle format: Invalid timestamp");
        }
        startTime = srtTimeToSeconds(splitTime[0]);
        endTime = srtTimeToSeconds(splitTime[1]);
        // Line 2+ is any text to display
        text = subtitleBlock.splice(2).join("\n");
    }
    return {
        startTime: startTime,
        endTime: endTime,
        text: text,
        print: function(index) {
            return index + "\n" + secondsToSrtTime(this.startTime) + " --> " + secondsToSrtTime(this.endTime) + "\n" + text;
        }
    }
}

var adjustTimestamp = function(timestamp, scaleFactor) {
    timestamp = (typeof timestamp === "string" ? srtTimeToSeconds(timestamp) : timestamp);
    timestamp = timestamp + scaleFactor.offset + (timestamp * scaleFactor.slope);
    return timestamp;
}

var adjustTimestamps = function(srt, scaleFactor) {
    var block;
    for(var i = 0; i < srt.subs.length; i++) {
        block = srt.subs[i];
        block.startTime = adjustTimestamp(block.startTime, scaleFactor);
        block.endTime = adjustTimestamp(block.endTime, scaleFactor);
        srt.subs[i] = block;
    }
    return srt;
}

var computeScaleFactor = function(sourceTimeA, destinationTimeA, sourceTimeB, destinationTimeB) {
    var offset, slope;
    sourceTimeA = srtTimeToSeconds(sourceTimeA);
    destinationTimeA = srtTimeToSeconds(destinationTimeA);
    sourceTimeB = srtTimeToSeconds(sourceTimeB);
    destinationTimeB = srtTimeToSeconds(destinationTimeB);
    if(sourceTimeB === null || destinationTimeB === null ||
        sourceTimeB === "" || destinationTimeB === "" ||
        isNaN(sourceTimeB) || isNaN(destinationTimeB) ||
        sourceTimeA === sourceTimeB || destinationTimeA === destinationTimeB)
    {
        slope = 0;
        offset = destinationTimeA - sourceTimeA;
    } else {
        /*
            sourceTimeA -> destinationTimeA
                offsetA = (destinationTimeA - sourceTimeA)
            sourceTimeB -> destinationTimeB
                offsetB = (destinationTimeB - sourceTimeB)
            
            slope = (offsetB - offsetA) / (sourceTimeB - sourceTimeA)
            offset = offsetA - (sourceTimeA * slope)
        */
        slope = ((destinationTimeB - sourceTimeB) - (destinationTimeA - sourceTimeA)) / (sourceTimeB - sourceTimeA);
        offset = (destinationTimeA - sourceTimeA) - (sourceTimeA * slope);
    }
    
    return {
        offset: offset,
        slope: slope
    };
}

var Srt = function(filePath, filename, callback) {
    var srt;
    srt = {
        filePath: filePath,
        filename: filename,
        subs: [],
        print: null
    }
    srt.print = function() {
        var data = "";
        for(var i = 0; i < srt.subs.length; i++) {
            data += srt.subs[i].print(i + 1);
            if(i < srt.subs.length - 1) {
                data += "\n\n";
            }
        }
        return data;
    };

    fs.readFile(filePath, "utf8", function(error, data) {
        var splitData, block, subtitle;
        if(!error) {
            data = data.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            splitData = data.split("\n\n");
            for(var i = 0; i < splitData.length; i++) {
                try {
                    subtitle = new Subtitle(splitData[i]);
                    srt.subs.push(new Subtitle(splitData[i]));
                } catch(e) {
                    console.log(e, splitData[i]);
                }
            }
            
            callback(null, srt);
        } else {
            callback(error, {});
        }
    });
}


module.exports = {
    Srt: Srt,
    srtTimeToSeconds: srtTimeToSeconds,
    secondsToSrtTime: secondsToSrtTime,
    computeScaleFactor: computeScaleFactor,
    adjustTimestamps: adjustTimestamps
}